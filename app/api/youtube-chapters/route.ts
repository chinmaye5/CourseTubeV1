import { NextRequest, NextResponse } from 'next/server';

interface Chapter {
    title: string;
    time: string;
    url: string;
}

function extractInitialData(html: string) {
    // Try multiple patterns to find the initial data
    const patterns = [
        /var ytInitialData\s*=\s*({[\s\S]*?});<\/script>/,
        /window\["ytInitialData"\]\s*=\s*({[\s\S]*?});<\/script>/,
        /ytInitialData\s*=\s*({[\s\S]*?});<\/script>/
    ];

    for (const pattern of patterns) {
        const match = html.match(pattern);
        if (match) {
            try {
                return JSON.parse(match[1]);
            } catch (err) {
                // Ignore parse errors
                continue;
            }
        }
    }
    return null;
}

function extractChapters(data: any): Chapter[] {
    try {
        // Method 1: Try engagement panels (new structure)
        const engagementPanels = data?.engagementPanels;
        if (engagementPanels) {
            for (const panel of engagementPanels) {
                const contents = panel?.engagementPanelSectionListRenderer?.content
                    ?.macroMarkersListRenderer?.contents;
                if (contents && Array.isArray(contents)) {
                    const areAutoGenerated = 'macroMarkersInfoItemRenderer' in contents[0];
                    const filtered = contents.slice(areAutoGenerated ? 1 : 0);

                    return filtered.map((item: any) => {
                        const c = item.macroMarkersListItemRenderer;
                        return {
                            title: c.title.simpleText,
                            time: c.timeDescription.simpleText,
                            url: `https://youtube.com${c.onTap.commandMetadata.webCommandMetadata.url}`
                        };
                    });
                }
            }
        }

        // Method 2: Try player overlays (alternative structure)
        const playerOverlays = data?.playerOverlays?.playerOverlayRenderer?.decoratedPlayerBarRenderer
            ?.decoratedPlayerBarRenderer?.playerBar?.multiMarkersPlayerBarRenderer
            ?.markersMap?.[0]?.value?.chapters;

        if (playerOverlays && Array.isArray(playerOverlays)) {
            return playerOverlays.map((chapter: any) => ({
                title: chapter.chapterRenderer?.title?.simpleText || 'Untitled',
                time: formatTime(chapter.chapterRenderer?.timeRangeStartMillis || 0),
                url: `https://youtube.com/watch?v=${data?.currentVideoEndpoint?.watchEndpoint?.videoId}&t=${Math.floor(chapter.chapterRenderer?.timeRangeStartMillis / 1000)}`
            }));
        }

        // Method 3: Try video description chapters
        const descriptionChapters = data?.contents?.twoColumnWatchNextResults?.results?.results?.contents
            ?.[1]?.videoSecondaryInfoRenderer?.metadataRowContainer?.metadataRowContainerRenderer?.rows
            ?.find((row: any) => row.metadataRowRenderer?.title?.simpleText === 'Chapters')
            ?.metadataRowRenderer?.contents?.[0]?.runs;

        if (descriptionChapters && Array.isArray(descriptionChapters)) {
            const chapters: Chapter[] = [];
            for (let i = 0; i < descriptionChapters.length; i += 2) {
                if (descriptionChapters[i]?.text && descriptionChapters[i + 1]?.text) {
                    chapters.push({
                        title: descriptionChapters[i].text,
                        time: descriptionChapters[i + 1].text,
                        url: `https://youtube.com${descriptionChapters[i]?.navigationEndpoint?.commandMetadata?.webCommandMetadata?.url || ''}`
                    });
                }
            }
            if (chapters.length > 0) return chapters;
        }

        return [];
    } catch (err) {
        return [];
    }
}

function formatTime(milliseconds: number): string {
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
        return `${hours}:${String(minutes % 60).padStart(2, '0')}:${String(seconds % 60).padStart(2, '0')}`;
    } else {
        return `${minutes}:${String(seconds % 60).padStart(2, '0')}`;
    }
}

export async function POST(request: NextRequest) {
    try {
        const { videoId } = await request.json();

        if (!videoId) {
            return NextResponse.json({ error: 'Video ID is required' }, { status: 400 });
        }

        const url = `https://www.youtube.com/watch?v=${videoId}`;
        const res = await fetch(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
        });

        if (!res.ok) {
            throw new Error(`Failed to fetch YouTube page: ${res.status} ${res.statusText}`);
        }

        const html = await res.text();
        const data = extractInitialData(html);

        if (!data) {
            throw new Error('Could not extract ytInitialData from YouTube page');
        }

        const chapters = extractChapters(data);

        if (chapters.length === 0) {
            return NextResponse.json({
                error: 'No chapters found for this video',
                chapters: []
            }, { status: 404 });
        }

        return NextResponse.json({ chapters });
    } catch (error) {
        return NextResponse.json(
            {
                error: error instanceof Error ? error.message : 'Internal server error',
                chapters: []
            },
            { status: 500 }
        );
    }
}